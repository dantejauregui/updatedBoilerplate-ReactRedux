#!/usr/bin/env node
'use strict';

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _url = require('url');

var _string_decoder = require('string_decoder');

var _micro = require('micro');

var _micro2 = _interopRequireDefault(_micro);

var _chalk = require('chalk');

var _args = require('args');

var _args2 = _interopRequireDefault(_args);

var _handlebars = require('handlebars');

var _istextorbinary = require('istextorbinary');

var _filesize = require('filesize');

var _filesize2 = _interopRequireDefault(_filesize);

var _mime = require('mime');

var _mime2 = _interopRequireDefault(_mime);

var _denodeify = require('denodeify');

var _denodeify2 = _interopRequireDefault(_denodeify);

var _microCompress = require('micro-compress');

var _microCompress2 = _interopRequireDefault(_microCompress);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Native


// Packages


_args2.default.option('port', 'Port to listen on', process.env.PORT || 3000).option('cache', 'How long static files should be cached in the browser (seconds)', 3600).option('single', 'Serve single page apps with only one index.html').option('unzipped', 'Disable GZIP compression');

const flags = _args2.default.parse(process.argv);
const directory = _args2.default.sub[0];

process.env.ASSET_DIR = '/' + Math.random().toString(36).substr(2, 10);

let current = process.cwd();

if (directory) {
  current = _path2.default.resolve(process.cwd(), directory);
}

const isDir = (() => {
  var _ref = _asyncToGenerator(function* (dir) {
    let stats;

    try {
      stats = yield (0, _denodeify2.default)(_fs2.default.stat)(dir);
    } catch (err) {
      return false;
    }

    if (stats.isDirectory()) {
      return true;
    }

    return false;
  });

  return function isDir(_x) {
    return _ref.apply(this, arguments);
  };
})();

const exists = (() => {
  var _ref2 = _asyncToGenerator(function* (file) {
    try {
      yield (0, _denodeify2.default)(_fs2.default.stat)(file);
    } catch (err) {
      return false;
    }

    return true;
  });

  return function exists(_x2) {
    return _ref2.apply(this, arguments);
  };
})();

const prepareView = () => {
  let viewContent = false;
  const viewPath = _path2.default.normalize(_path2.default.join(__dirname, '/../../views/index.hbs'));

  try {
    viewContent = _fs2.default.readFileSync(viewPath, 'utf8');
  } catch (err) {
    throw err;
  }

  return (0, _handlebars.compile)(viewContent);
};

const ignoredFiles = ['.DS_Store', '.git/'];

const renderDirectory = (() => {
  var _ref3 = _asyncToGenerator(function* (dir) {
    let files = [];
    const subPath = _path2.default.relative(current, dir);

    if (!(yield exists(dir))) {
      return false;
    }

    try {
      files = yield (0, _denodeify2.default)(_fs2.default.readdir)(dir);
    } catch (err) {
      throw err;
    }

    for (const file of files) {
      const filePath = _path2.default.resolve(dir, file);
      const index = files.indexOf(file);
      const details = _path2.default.parse(filePath);

      details.ext = details.ext.split('.')[1];
      details.relative = _path2.default.join(subPath, details.base);

      if (yield isDir(filePath)) {
        details.base += '/';
      } else {
        let fileStats;

        try {
          fileStats = yield (0, _denodeify2.default)(_fs2.default.stat)(filePath);
        } catch (err) {
          throw err;
        }

        details.size = (0, _filesize2.default)(fileStats.size, { round: 0 });
      }

      if (ignoredFiles.indexOf(details.base) > -1) {
        delete files[index];
      } else {
        files[files.indexOf(file)] = details;
      }
    }

    if (dir.indexOf(current + '/') > -1) {
      files.unshift({
        base: '..',
        relative: '..'
      });
    }

    const render = prepareView();
    const directory = _path2.default.join(_path2.default.basename(current), subPath, '/');
    const pathParts = directory.split('/');

    const paths = [];
    pathParts.pop();

    for (const part in pathParts) {
      if (!{}.hasOwnProperty.call(pathParts, part)) {
        continue;
      }

      let before = 0;
      const parents = [];

      while (before <= part) {
        parents.push(pathParts[before]);
        before++;
      }

      parents.shift();

      paths.push({
        name: pathParts[part],
        url: '/' + parents.join('/')
      });
    }

    const details = {
      port: flags.port,
      files,
      assetDir: process.env.ASSET_DIR,
      directory,
      nodeVersion: process.version.split('v')[1],
      paths
    };

    return render(details);
  });

  return function renderDirectory(_x3) {
    return _ref3.apply(this, arguments);
  };
})();

const handler = (() => {
  var _ref4 = _asyncToGenerator(function* (req, res) {
    const { pathname } = (0, _url.parse)(req.url);
    let related = _path2.default.parse(_path2.default.join(current, pathname));

    if (related.dir.indexOf(process.env.ASSET_DIR) > -1) {
      const relative = _path2.default.relative(process.env.ASSET_DIR, pathname);
      related = _path2.default.parse(_path2.default.join(__dirname, '/../assets', relative));
    }

    related = decodeURIComponent(_path2.default.format(related));

    if (!(yield exists(related)) && flags.single === undefined) {
      return (0, _micro.send)(res, 404, 'Not found');
    }

    // Check if file or directory path
    if (_path2.default.parse(related).ext === '') {
      let indexPath = _path2.default.join(related, '/index.html');

      if (!(yield isDir(related)) && flags.single === undefined) {
        return (0, _micro.send)(res, 404, 'Not found');
      }

      res.setHeader('Content-Type', _mime2.default.lookup(indexPath) + '; charset=utf-8');

      if (!(yield exists(indexPath))) {
        // Try to render the current directory's content
        const renderedDir = yield renderDirectory(related);

        // If it works, send the directory listing to the user
        if (renderedDir) {
          return (0, _micro.send)(res, 200, renderedDir);
        }

        // And if it doesn't, see if it's a single page application
        // If that's not true either, send an error
        if (!flags.single) {
          return (0, _micro.send)(res, 404, 'Not found');
        }

        // But IF IT IS true, load the SPA's root index file
        indexPath = _path2.default.join(current, '/index.html');
      }

      let indexContent;

      try {
        indexContent = yield (0, _denodeify2.default)(_fs2.default.readFile)(indexPath, 'utf8');
      } catch (err) {
        throw err;
      }

      return (0, _micro.send)(res, 200, indexContent);
    }

    let body = 'Not able to load file!';
    let stats;
    let binaryStat;

    try {
      body = yield (0, _denodeify2.default)(_fs2.default.readFile)(related);
      stats = yield (0, _denodeify2.default)(_fs2.default.stat)(related);
      binaryStat = yield (0, _denodeify2.default)(_istextorbinary.isBinary)(_path2.default.parse(related).base, body);
    } catch (err) {
      throw err;
    }

    const getETag = function (s) {
      return '"' + s.dev + '-' + s.ino + '-' + s.mtime.getTime() + '"';
    };

    let requestDate = req.headers['if-modified-since'];
    let statusCode = 200;

    if (requestDate) {
      requestDate = new Date(requestDate);

      if (requestDate.getTime() === stats.mtime.getTime()) {
        statusCode = 304;
      }
    }

    const defaultHeaders = {
      'Cache-Control': 'public, max-age=' + flags.cache,
      'Pragma': 'public',
      'ETag': getETag(stats)
    };

    for (const header in defaultHeaders) {
      if (!{}.hasOwnProperty.call(defaultHeaders, header)) {
        continue;
      }

      res.setHeader(header, defaultHeaders[header]);
    }

    if (binaryStat) {
      res.statusCode = statusCode;
      res.end(body, 'binary');
    } else {
      const decoder = new _string_decoder.StringDecoder('utf8');
      let contentType = _mime2.default.lookup(related);

      if (!_path2.default.parse(related).ext) {
        contentType = 'text/plain';
      }

      res.setHeader('Content-Type', contentType + '; charset=utf-8');
      (0, _micro.send)(res, statusCode, decoder.write(body));
    }
  });

  return function handler(_x4, _x5) {
    return _ref4.apply(this, arguments);
  };
})();

const server = flags.unzipped ? (0, _micro2.default)(handler) : (0, _micro2.default)((0, _microCompress2.default)(handler));

server.listen(flags.port, _asyncToGenerator(function* () {
  const details = server.address();

  process.on('SIGINT', function () {
    server.close();
    process.exit(0);
  });

  if (!(yield isDir(current))) {
    console.error((0, _chalk.red)('Specified directory doesn\'t exist!'));
    process.exit(1);
  }

  if (!process.env.NOW) {
    console.log((0, _chalk.green)(`Running on http://localhost:${ details.port }`));
  }
}));